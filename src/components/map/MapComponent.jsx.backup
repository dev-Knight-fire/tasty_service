"use client";
import React, { useRef, useEffect, useState } from 'react';
import * as maptilersdk from '@maptiler/sdk';
import "@maptiler/sdk/dist/maptiler-sdk.css";
import './map.css';
import { collection, getDocs, getDoc, query, where, doc } from "firebase/firestore";
import { db } from '../../firebase/firestore';
import ServiceDetailsModal from './serviceDetailsModal';
import { useLang } from '@/contexts/LangContext';
import { useSearchParams } from 'next/navigation';

// Category definitions for filtering and UI


export default function MapComponent({ category }) {
  const { messages } = useLang();
  const searchParams = useSearchParams();
  const locationValue = searchParams.get('locationValue');
  const mapContainer = useRef(null);
  const map = useRef(null);
  const markerRef = useRef(null); // Ref to store the marker instance for search
  const serviceMarkersRef = useRef([]); // Store service markers to clean up if needed
  const warsaw = { lng: 21.017532, lat: 52.237049 };
  const zoom = 14;
  const [searchQuery, setSearchQuery] = useState(locationValue || '');
  const [debouncedSearchQuery, setDebouncedSearchQuery] = useState('');
  const [searchResults, setSearchResults] = useState([]);
  const [isSearching, setIsSearching] = useState(false);
  const [services, setServices] = useState([]);
  const [loading, setLoading] = useState(false);
  const [selectedService, setSelectedService] = useState(null);

  const CATEGORY_DEFS = [
    { key: "all", label: messages["alltypesTitle"], icon: "🌍", color: "bg-gray-200" },
    { key: "localFood", label: messages["localfoodTitle"], icon: "🛒", color: "bg-green-200" },
    { key: "fairTrade", label: messages["fairtradeTitle"], icon: "🤝", color: "bg-yellow-200" },
    { key: "zeroWaste", label: messages["zerowasteTitle"], icon: "♻️", color: "bg-emerald-200" },
    { key: "foodSharing", label: messages["foodsharingTitle"], icon: "🍽️", color: "bg-orange-200" },
    { key: "repairPoints", label: messages["repairpointsTitle"], icon: "🔧", color: "bg-gray-300" },
    { key: "giveTake", label: messages["givetakeTitle"], icon: "📚", color: "bg-purple-200" },
    { key: "bioWaste", label: messages["biowasteTitle"], icon: "🌲", color: "bg-green-300" },
    { key: "ecoMarkets", label: messages["ecomarketsTitle"], icon: "🏛️", color: "bg-pink-200" },
    { key: "resinWaste", label: messages["resinwasteTitle"], icon: "🗑️", color: "bg-red-200" }
  ];

  // Multi-select: array of selected category keys (except "all")
  const [selectedCategories, setSelectedCategories] = useState(
    category && Array.isArray(category) ? category : []
  );
  maptilersdk.config.apiKey = 'GOq67Pre20jQoPdwn8zY';

  // Initialize map
  useEffect(() => {
    if (map.current) return;
    map.current = new maptilersdk.Map({
      container: mapContainer.current,
      style: maptilersdk.MapStyle.STREETS,
      center: [warsaw.lng, warsaw.lat],
      zoom: zoom
    });
  }, [warsaw.lng, warsaw.lat, zoom]);

  // Fetch services from Firestore
  useEffect(() => {
    setLoading(true);
    (async () => {
      try {
        const listsRef = collection(db, "lists");
        const q = query(listsRef, where("status", "==", "approved"));
        const querySnapshotUser = await getDocs(q);

        // Get document references for each approved user
        const docRefs = querySnapshotUser.docs.map((userdoc) =>
          doc(db, "lists", userdoc.id)
        );

        // Fetch all documents data
        const docSnaps = await Promise.all(
          docRefs.map((docRef) => getDoc(docRef))
        );

        const data = docSnaps
          .map((docSnap) => {
            if (!docSnap.exists()) return null;
            const docData = docSnap.data();
            return {
              id: docSnap.id,
              ...docData
            };
          })
          .filter((item) => item !== null);
        setServices(data);
      } catch (error) {
        console.error("Error fetching lists from Firestore:", error);
      } finally {
        setLoading(false);
      }
    })();
  }, [locationValue]);

  // Filtered services by selected categories (multi-select)
  const filteredServices =
    selectedCategories.length === 0 || selectedCategories.includes("all")
      ? services
      : services.filter(s =>
          Array.isArray(s.entryType)
            ? s.entryType.some(cat => selectedCategories.includes(cat))
            : selectedCategories.includes(s.entryType)
        );

  // Add service markers to the map
  useEffect(() => {
    if (!map.current) return;
    // Remove previous service markers
    serviceMarkersRef.current.forEach(marker => marker.remove());
    serviceMarkersRef.current = [];

    // Category to icon mapping
    const categoryIcons = CATEGORY_DEFS.reduce((acc, cat) => {
      if (cat.key !== "all") acc[cat.key] = cat.icon;
      return acc;
    }, {});

    // Add new markers for each service with valid location
    filteredServices.forEach(service => {
      // Accept both {location: {lat, lng}} or {lat, lng} directly
      let lat, lng;
      if (service.location && typeof service.location.lat === "number" && typeof service.location.lng === "number") {
        lat = service.location.lat;
        lng = service.location.lng;
      } else if (typeof service.lat === "number" && typeof service.lng === "number") {
        lat = service.lat;
        lng = service.lng;
      }
      if (typeof lat === "number" && typeof lng === "number") {
        // Determine icon based on first matching category
        let icon = "📍"; // default icon
        if (service.entryType) {
          if (Array.isArray(service.entryType)) {
            const found = service.entryType.find(cat => categoryIcons[cat]);
            if (found) icon = categoryIcons[found];
          } else if (categoryIcons[service.entryType]) {
            icon = categoryIcons[service.entryType];
          }
        }

        // Create a custom marker element with the icon
        const el = document.createElement('div');
        el.style.display = 'flex';
        el.style.alignItems = 'center';
        el.style.justifyContent = 'center';
        el.style.width = '40px';
        el.style.height = '40px';
        el.style.borderRadius = '50%';
        el.style.background = 'green';
        el.style.border = '2px solid red';
        el.style.boxShadow = '0 2px 6px rgba(0,0,0,0.15)';
        el.style.fontSize = '24px';
        el.style.lineHeight = '1';
        el.style.cursor = 'pointer';
        el.textContent = icon;

        // Add click event to show modal with service details
        el.addEventListener('click', (e) => {
          e.stopPropagation();
          setSelectedService(service);
          // Center the map on the service and zoom to 18
          if (map.current) {
            map.current.flyTo({
              center: [lng, lat],
              zoom: 17,
              essential: true
            });
          }
        });

        const marker = new maptilersdk.Marker({ element: el })
          .setLngLat([lng, lat])
          .addTo(map.current);
        serviceMarkersRef.current.push(marker);
      }
    });
    // Clean up on unmount
    return () => {
      serviceMarkersRef.current.forEach(marker => marker.remove());
      serviceMarkersRef.current = [];
    };
  }, [filteredServices]);

  // Modal component for service details (completed)

  const handleSearch = async () => {
    if (!searchQuery.trim()) return;
    setIsSearching(true);
    try {
      // Using MapTiler Geocoding API
      const response = await fetch(
        `https://api.maptiler.com/geocoding/${encodeURIComponent(searchQuery)}.json?key=${maptilersdk.config.apiKey}&limit=10`
      );
      const data = await response.json();
      setSearchResults(data.features || []);
    } catch (error) {
      console.error('Search error:', error);
      setSearchResults([]);
    } finally {
      setIsSearching(false);
    }
  };

  const handleResultClick = (result) => {
    const [lng, lat] = result.center;

    // Remove previous search marker if exists
    if (markerRef.current) {
      markerRef.current.remove();
      markerRef.current = null;
    }

    // Add new marker at the selected location
    markerRef.current = new maptilersdk.Marker({ color: "#2563eb" })
      .setLngLat([lng, lat])
      .addTo(map.current);

    map.current.flyTo({
      center: [lng, lat],
      zoom: 16,
      essential: true
    });
    setSearchResults([]);
    setSearchQuery(result.place_name);
  };

  const handleKeyPress = (e) => {
    if (e.key === 'Enter') {
      handleSearch();
    }
  };

  // Debounce the search query
  useEffect(() => {
    const timer = setTimeout(() => {
      setDebouncedSearchQuery(searchQuery);
    }, 500); // 500ms delay
    
    return () => clearTimeout(timer);
  }, [searchQuery]);

  // Trigger search when debounced query changes
  useEffect(() => {
    if (debouncedSearchQuery.trim()) {
      handleSearch();
    }
  }, [debouncedSearchQuery]);


  return (
    <div className="map-wrap relative">
      {/* Service Details Modal */}
      {selectedService && (
        <ServiceDetailsModal
          service={selectedService}
          onClose={() => setSelectedService(null)}
          services={services}
        />
      )}
      {/* Search Bar & Category Filter */}
      <div className="absolute top-4 left-4 z-10 w-96 max-w-full">
        <div className="bg-white rounded-lg shadow-lg p-4">
          <div className="flex items-center space-x-2">
            <input
              type="text"
              value={searchQuery}
              onChange={(e) => setSearchQuery(e.target.value)}
              onKeyPress={handleKeyPress}
              placeholder="Search address..."
              className="flex-1 px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-400"
            />
            <button
              onClick={handleSearch}
              disabled={isSearching}
              className={`px-4 py-2 rounded-md bg-blue-600 text-white flex items-center justify-center transition
                ${isSearching ? "opacity-70 cursor-not-allowed" : "hover:bg-blue-700"}
              `}
              type="button"
            >
              {isSearching ? (
                <svg className="animate-spin h-5 w-5 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                  <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                  <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8v8z"></path>
                </svg>
              ) : (
                <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" />
                </svg>
              )}
            </button>
          </div>
          {/* Search Results Dropdown */}
          {searchResults.length > 0 && (
            <div className="mt-2 bg-white border border-gray-200 rounded-md shadow-lg max-h-60 overflow-y-auto">
              {searchResults.map((result, index) => (
                <button
                  key={index}
                  type="button"
                  onClick={() => handleResultClick(result)}
                  className="w-full text-left px-3 py-2 border-b border-gray-100 last:border-b-0 hover:bg-gray-100 transition"
                  style={{ borderRadius: 0 }}
                >
                  <div className="text-sm font-medium text-gray-900">{result.text}</div>
                  <div className="text-xs text-gray-500">{result.place_name}</div>
                </button>
              ))}
            </div>
          )}
        </div>
      </div>
      <div ref={mapContainer} className="map" />
    </div>
  );
}